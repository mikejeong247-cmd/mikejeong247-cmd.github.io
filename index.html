<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Emoji Search — Pro (SAFE-only)</title>
  <style>
    :root{--gap:14px;}
    body{font-family:system-ui,apple sd gothic neo,Segoe UI,Roboto,Helvetica,Arial;
         margin:24px;color:#222;}
    .toolbar{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-bottom:10px}
    .search{flex:1;min-width:260px;max-width:640px;padding:12px 16px;font-size:18px;
            border:1px solid #ddd;border-radius:12px;outline:none}
    .hint{color:#666;font-size:13px}
    .grid{display:grid;grid-template-columns:repeat(auto-fill, minmax(180px,1fr));gap:var(--gap);}
    .card{border:1px solid #eee;border-radius:12px;padding:12px 14px;background:#fff}
    .emoji{font-size:36px;line-height:1;margin-bottom:6px}
    .name{font-weight:700;margin:2px 0 6px}
    .meta{color:#666;font-size:12px}
    mark{background:#fff2a8;padding:0 .5px;border-radius:2px}
    .zero{margin-top:16px;color:#666}
  </style>
</head>
<body>
  <div class="toolbar">
    <input id="q" class="search" placeholder="검색: 하트 / ㅋㅋ / 草 / ok … (CJK은 글자 1개라도 겹치면 노출)">
    <span class="hint">SAFE 전용 매칭 · 밈 제외 · 경량 점수화</span>
  </div>
  <div id="list" class="grid"></div>
  <div id="zero" class="zero" style="display:none;">결과가 없습니다. 철자/언어를 바꿔보세요.</div>

  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script>
/** ====== 설정 (폼절정 전용) ====== */

// 1) CSV 경로: BUILD 시트를 CSV로 공개한 최종 주소로 교체
const DATA_URL = "여기에_내_BUILD_CSV_URL_붙여넣기";

// 2) 카드 타이틀 언어 우선순위(기본: 한→일→중→영, 이후 다른 언어 자동 보조)
const NAME_FIELDS_BASE = [
  "name_ko","name_ja","name_zh-cn","name_en",
  "name_es","name_ar","name_pt","name_ru","name_fr","name_tr",
  "name_id","name_hi","name_de"
];

// 3) SAFE 인덱스의 '기본 키' 목록 (여기에 대응하는 *_alt, *_v2 등은 자동 흡수됨)
const SAFE_FIELDS_BASE = [
  "keywords_ko_safe","keywords_ja_safe","keywords_zh-cn_safe",
  "keywords_es_safe","keywords_ar_safe","keywords_pt_safe",
  "keywords_ru_safe","keywords_fr_safe","keywords_tr_safe",
  "keywords_id_safe","keywords_hi_safe","keywords_de_safe"
];

// 4) 검색/정렬 파라미터
const MAX_RESULTS = 400;
const SCORE = { nameHit: 3, tokenHit: 1, categoryHit: 0.5 };

/** ====== 유틸 ====== */
const rmDiacritics = s => (s||"").normalize("NFD").replace(/[\u0300-\u036f]/g,"");
const toLower = s => rmDiacritics(String(s||"")).toLowerCase();
const splitLatin = s => toLower(s).split(/[^a-z0-9]+/).filter(t=>t.length>1); // 라틴: 2자 이상 토큰
const uniq = arr => [...new Set(arr)];
const isLatin = s => /^[a-z0-9\s,._-]+$/i.test(rmDiacritics(s||"")); // 라틴(영문/숫자/공백/구두점)

/** ====== 데이터 로드 ====== */
let rows = [];
let ready = false;

Papa.parse(DATA_URL, {
  download:true, header:true, skipEmptyLines:true,
  complete: (res) => {
    // 0) 모든 키를 소문자/trim으로 정규화 (zh-CN → zh-cn)
    const normalizeKeys = row => {
      const o = {};
      for (const k in row) {
        const nk = String(k||"").trim().toLowerCase();
        o[nk] = row[k];
      }
      return o;
    };
    const data = res.data.map(normalizeKeys);
    const headers = Object.keys(data[0] || {});

    // 1) *_alt, *_v2 같은 변형을 자동 흡수
    const expandVariants = (baseList) => {
      const bases = baseList.map(b => b.toLowerCase());
      return headers.filter(h =>
        bases.some(base => h === base || h.startsWith(base + "_"))
      );
    };

    // 2) SAFE 인덱스에 넣을 모든 필드(alt 변형 포함)
    const EXPANDED_SAFE_FIELDS = expandVariants(SAFE_FIELDS_BASE);

    // 3) 이름 선택용 후보 생성: base별로 manual_alt > alt > manual > base 우선
    const nameCandidatesFor = (base) => ([
      `${base}_manual_alt`, `${base}_alt`, `${base}_manual`, base
    ]);

    // 4) 전체 이름 후보 리스트(언어 우선순위 적용)
    const NAME_FIELDS_ALL = NAME_FIELDS_BASE.flatMap(nameCandidatesFor);

    // 5) 토큰 보조용 필드 (영문 이름은 라틴 검색 보조로 유용)
    const TOKEN_AUX_FIELDS = ["name_en","name_en_alt","name_en_manual","name_en_manual_alt"]
      .filter(f => headers.includes(f));

    // 6) 레코드 가공
    rows = data.map(r => {
      // 6-1) 표시 이름 고르기 (우선순위대로 첫 번째 non-empty)
      const name = (NAME_FIELDS_ALL.find(f => r[f]) && NAME_FIELDS_ALL.map(f=>r[f]).find(Boolean)) || r["name_en"] || "";

      // 6-2) SAFE 인덱스 문자열(전 언어) + 토큰 보조 필드 결합
      const safeStrings = [
        ...EXPANDED_SAFE_FIELDS.map(f => r[f] || ""),
        ...TOKEN_AUX_FIELDS.map(f => r[f] || "")
      ].join(",");

      const idxStr = toLower(safeStrings);
      const idxChars = idxStr;                      // 비라틴: 문자 단위 포함 검사
      const idxLatinTokens = uniq(splitLatin(idxStr)); // 라틴: 토큰 배열

      // 6-3) 하이라이트 표시용(ko SAFE 대표)
      const safeKo = r["keywords_ko_safe"] || r["keywords_ko_safe_alt"] || "";

      return {
        id: r.id, category: r.category || "", code: r.code || "", emoji: r.emoji || "",
        name, name_en: r["name_en"] || "",
        idxChars, idxLatinTokens,
        safeKo
      };
    });

    ready = true;
    render(rows.slice(0, 120));
  }
});

/** ====== 검색 ====== */
const $q = document.getElementById("q");
const $list = document.getElementById("list");
const $zero = document.getElementById("zero");
let t;

$q.addEventListener("input", () => {
  clearTimeout(t);
  t = setTimeout(runSearch, 60);
});

function runSearch(){
  if(!ready){ return; }
  const qRaw = $q.value || "";
  const q = toLower(qRaw.trim());
  if(!q){
    render(rows.slice(0, 120));
    return;
  }

  // 라틴 vs 비라틴 분기
  const latin = isLatin(q);
  const chars  = latin ? [] : uniq(q.split("").filter(Boolean)); // 비라틴: 문자 OR
  const tokens = latin ? uniq(q.split(/[\s,]+/).map(toLower).filter(Boolean)) : []; // 라틴: 토큰 OR

  const hits = [];
  for(const r of rows){
    let score = 0;
    let matched = false;

    if(!latin){
      // 비라틴: 1글자라도 겹치면 매칭
      for(const ch of chars){
        if(r.idxChars.includes(ch)){
          matched = true;
          score += SCORE.tokenHit;
        }
      }
      // 이름에 포함되면 가중 + 매칭 인정
      for(const ch of chars){
        if(toLower(r.name).includes(ch)){
          score += SCORE.nameHit;
          matched = true; // ★ 이름만 걸려도 결과 포함
        }
      }
    }else{
      // 라틴: 토큰(부분문자열) OR
      for(const t of tokens){
        if(r.idxLatinTokens.includes(t) || toLower(r.name_en).includes(t) || toLower(r.name).includes(t)){
          matched = true;
          score += SCORE.tokenHit;
          if(toLower(r.name).includes(t)) score += SCORE.nameHit;
        }
      }
    }

    // 카테고리 보너스
    for(const key of (latin ? tokens : chars)){
      if(toLower(r.category).includes(key)) score += SCORE.categoryHit;
    }

    if(matched){
      hits.push({r, score});
    }
  }

  // 점수 정렬 → 상위만 노출
  hits.sort((a,b)=> b.score - a.score);
  render(hits.slice(0, MAX_RESULTS).map(x=>x.r));
}

/** ====== 렌더 & 하이라이트 ====== */
function esc(s){return (s||"").replace(/[&<>"]/g, m=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;"}[m]));}

function highlight(text, query){
  if(!query) return esc(text);
  const q = toLower(query);
  const latin = isLatin(q);

  if(!latin){
    // 비라틴: 문자 집합으로 하이라이트(1글자 겹치면 마킹)
    const set = new Set(q.split(""));
    let out = "";
    for(const ch of text){
      if(set.has(toLower(ch))) out += "<mark>"+esc(ch)+"</mark>";
      else out += esc(ch);
    }
    return out;
  }else{
    // 라틴: 토큰 OR
    const tokens = uniq(q.split(/[\s,]+/).filter(Boolean)).sort((a,b)=>b.length-a.length);
    let html = esc(text);
    for(const t of tokens){
      if(!t) continue;
      const re = new RegExp("("+t.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")+")","ig");
      html = html.replace(re, "<mark>$1</mark>");
    }
    return html;
  }
}

function render(items){
  if(!items.length){
    $list.innerHTML = "";
    $zero.style.display = "block";
    return;
  }
  $zero.style.display = "none";
  const q = $q.value || "";
  $list.innerHTML = items.map(r => `
    <div class="card">
      <div class="emoji">${r.emoji || "⬜"}</div>
      <div class="name">${highlight(r.name, q)}</div>
      <div class="meta">${esc(r.category)} · ${esc(r.code)}</div>
      ${r.safeKo ? `<div class="meta">${highlight(r.safeKo, q)}</div>` : ""}
    </div>
  `).join("");
}
</script>
</body>
</html>
