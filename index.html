<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Emoji Search — Pro (SAFE-only, Category View)</title>
  <style>
    :root{--gap:0;}
    body{font-family:system-ui,apple sd gothic neo,Segoe UI,Roboto,Helvetica,Arial;margin:16px;color:#222;}
    .toolbar{display:flex;gap:10px;flex-wrap:wrap;align-items:center;margin-bottom:10px}
    .search{flex:1;min-width:260px;max-width:680px;padding:10px 14px;font-size:16px;border:1px solid #ddd;border-radius:12px;outline:none}
    .hint{color:#666;font-size:12px}

    /* 상태 출력 */
    .status{font-size:12px;color:#666;margin:6px 0 8px;display:none}
    .status.err{color:#c00}
    .status.ok{color:#2a7}

    /* 카테고리 섹션 */
    #list{display:block}
    .sec{margin:10px 0 14px}
    .cat{font-weight:700;font-size:13px;margin:6px 0 4px;display:flex;align-items:center;gap:6px}
    .cnt{color:#999;font-weight:400;font-size:12px}

    /* 이모지 타일: 10px, 가로 간격 0, 세로 2px */
    .emojis{display:flex;flex-wrap:wrap;column-gap:0;row-gap:2px}
    .e{width:10px;height:10px;display:inline-flex;align-items:center;justify-content:center}
    .glyph{font-size:10px;line-height:1}

    /* 상세정보(name/keywords): 검색 시에만 보임 */
    .d{display:none}
    body.searching .emojis{display:block}
    body.searching .e{width:auto;height:auto;display:flex;align-items:flex-start;gap:8px;margin:4px 0}
    body.searching .glyph{font-size:10px;line-height:1;margin-top:2px}
    body.searching .d{display:block}
    .nm{font-weight:700;font-size:12px;margin-bottom:2px}
    .kw{color:#666;font-size:11px}
    mark{background:#fff2a8;padding:0 .5px;border-radius:2px}

    .zero{margin-top:12px;color:#666}
  </style>
</head>
<body>
  <div class="toolbar">
    <input id="q" class="search" placeholder="검색: 하트 / ㅋㅋ / 草 / حب / любовь / ok … (비라틴은 1글자만 겹쳐도 매칭)">
    <span class="hint">SAFE 전용 · 대카테고리별 묶음 · 검색 시에만 name/keywords 표시</span>
  </div>

  <div id="status" class="status"></div>
  <div id="list"></div>
  <div id="zero" class="zero" style="display:none;">결과가 없습니다. 철자/언어를 바꿔보세요.</div>

  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script>
  /** ====== 설정 (폼절정 전용) ====== */

  // 1) BUILD 시트를 CSV로 공개한 최종 주소를 넣으세요.
  const DATA_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vT_RAfp9VnhQCpOkq9fBnu3b44r6jTB9EyT4qefGNSOf7R0SKuvEt_OvFs_qHLFQA9a3VRade4mxsjA/pub?gid=813614977&single=true&output=csv";

  // 2) 표시 이름 우선순위: ko → ja → zh-cn → en (필요 시 순서 변경)
  //    이름은 manual_alt > alt > manual > base 순으로 자동 보강됩니다.
  const NAME_FIELDS_BASE = [
    "name_ko","name_ja","name_zh-cn","name_en",
    "name_es","name_ar","name_pt","name_ru","name_fr","name_tr",
    "name_id","name_hi","name_de"
  ];

  // 3) SAFE 인덱스 기본 키(여기에 대응하는 *_alt, *_v2 등은 자동 흡수)
  const SAFE_FIELDS_BASE = [
    "keywords_ko_safe","keywords_ja_safe","keywords_zh-cn_safe",
    "keywords_es_safe","keywords_ar_safe","keywords_pt_safe",
    "keywords_ru_safe","keywords_fr_safe","keywords_tr_safe",
    "keywords_id_safe","keywords_hi_safe","keywords_de_safe"
  ];

  // 4) 검색/정렬 파라미터 — 전부 노출(성능 유의)
  const MAX_RESULTS = Infinity;
  const SCORE = { nameHit: 3, tokenHit: 1, categoryHit: 0.5 };

  /** ====== 유틸 ====== */
  const $ = sel => document.querySelector(sel);
  const setStatus = (msg, cls="") => { const s=$("#status"); s.textContent=msg; s.className="status "+cls; s.style.display=msg?"block":"none"; };
  const rmDiacritics = s => (s||"").normalize("NFD").replace(/[\u0300-\u036f]/g,"");
  const toLower = s => rmDiacritics(String(s||"")).toLowerCase();
  const splitLatin = s => toLower(s).split(/[^a-z0-9]+/).filter(t=>t.length>1); // 라틴: 2자 이상 토큰
  const uniq = arr => [...new Set(arr)];
  // 라틴 알파벳 여부로 분기(라틴: 토큰 OR / 비라틴: 문자 OR)
  const isLatin = s => /^[a-z0-9\s,._-]+$/i.test(rmDiacritics(s||""));
  const esc = s => (s||"").replace(/[&<>"]/g, m=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;"}[m]));

  /** ====== 데이터 로드 ====== */
  let rows = [];
  let ready = false;

  (async function load(){
    try{
      setStatus("데이터 불러오는 중…");
      // CSV 직접 가져와 상태코드/오류를 명확히 확인
      const resp = await fetch(DATA_URL, { cache:"no-store", mode:"cors" });
      if(!resp.ok) throw new Error("HTTP "+resp.status+" — CSV 접근 불가");
      const csv = await resp.text();
      setStatus("파싱 중…");

      // CSV 파싱
      const parsed = Papa.parse(csv, { header:true, skipEmptyLines:true });
      if(parsed.errors && parsed.errors.length){
        console.warn("Papa errors:", parsed.errors);
      }

      // 0) 키 소문자 정규화(zh-CN → zh-cn)
      const normRow = row => { const o={}; for(const k in row){ o[String(k||"").trim().toLowerCase()] = row[k]; } return o; };
      const data = parsed.data.map(normRow);
      if(!data.length) throw new Error("CSV가 비어있습니다 (행 없음)");

      const headers = Object.keys(data[0] || {});

      // 1) *_alt, *_v2 같은 변형 자동 흡수
      const expandVariants = (baseList) => {
        const bases = baseList.map(b => b.toLowerCase());
        return headers.filter(h => bases.some(base => h === base || h.startsWith(base + "_")));
      };

      // 2) SAFE 인덱스 필드 집합(alt 포함)
      const EXPANDED_SAFE_FIELDS = expandVariants(SAFE_FIELDS_BASE);

      // 3) 이름 후보: manual_alt > alt > manual > base
      const nameCandidatesFor = (base) => ([`${base}_manual_alt`, `${base}_alt`, `${base}_manual`, base]);
      const NAME_FIELDS_ALL = NAME_FIELDS_BASE.flatMap(nameCandidatesFor);

      // 4) 라틴 토큰 보조(영문 이름 계열)
      const TOKEN_AUX_FIELDS = ["name_en","name_en_alt","name_en_manual","name_en_manual_alt"].filter(f => headers.includes(f));

      // 5) 필수 필드 점검
      const required = ["id","category","code","emoji"];
      const missing = required.filter(k => !headers.includes(k));
      if(missing.length){
        throw new Error("필수 헤더 누락: " + missing.join(", "));
      }

      // 6) 레코드 가공
      rows = data.map(r => {
        const name = (NAME_FIELDS_ALL.find(f => r[f]) && NAME_FIELDS_ALL.map(f=>r[f]).find(Boolean)) || r["name_en"] || "";
        const safeStrings = [
          ...EXPANDED_SAFE_FIELDS.map(f => r[f] || ""),
          ...TOKEN_AUX_FIELDS.map(f => r[f] || "")
        ].join(",");

        const idxStr = toLower(safeStrings);
        const idxChars = idxStr;                         // 비라틴: 문자 포함 검사
        const idxLatinTokens = uniq(splitLatin(idxStr)); // 라틴: 토큰 배열
        const safeKo = r["keywords_ko_safe"] || r["keywords_ko_safe_alt"] || "";

        return {
          id: r.id, category: r.category || "", code: r.code || "", emoji: r.emoji || "",
          name, name_en: r["name_en"] || "",
          idxChars, idxLatinTokens,
          safeKo
        };
      });

      ready = true;
      setStatus(`로드 완료 — ${rows.length}개 항목`, "ok");
      render(rows); // 처음엔 카테고리별 전체 이모지(10px 타일) 표시
    }catch(e){
      setStatus("로드 실패: " + (e && e.message ? e.message : e), "err");
      console.error(e);
    }
  })();

  /** ====== 검색 ====== */
  const $q = document.getElementById("q");
  const $list = document.getElementById("list");
  const $zero = document.getElementById("zero");
  let t;

  $q.addEventListener("input", () => {
    clearTimeout(t);
    t = setTimeout(runSearch, 120); // 입력 반응 안정화
  });

  function runSearch(){
    if(!ready){ return; }
    const qRaw = $q.value || "";
    const q = toLower(qRaw.trim());

    if(!q){
      document.body.classList.remove("searching");
      render(rows);
      return;
    }
    document.body.classList.add("searching");

    const latin = isLatin(q);
    const chars  = latin ? [] : uniq(q.split("").filter(Boolean));
    const tokens = latin ? uniq(q.split(/[\s,]+/).map(toLower).filter(Boolean)) : [];

    const hits = [];
    for(const r of rows){
      let score = 0;
      let matched = false;

      if(!latin){
        // 비라틴: 1글자라도 겹치면 매칭
        for(const ch of chars){
          if(r.idxChars.includes(ch)){
            matched = true;
            score += SCORE.tokenHit;
          }
        }
        // 이름에 포함되면 가중 + 매칭 인정
        for(const ch of chars){
          if(toLower(r.name).includes(ch)){
            score += SCORE.nameHit;
            matched = true;
          }
        }
      }else{
        // 라틴: 토큰(부분문자열) OR
        for(const tkn of tokens){
          if(r.idxLatinTokens.includes(tkn) || toLower(r.name_en).includes(tkn) || toLower(r.name).includes(tkn)){
            matched = true;
            score += SCORE.tokenHit;
            if(toLower(r.name).includes(tkn)) score += SCORE.nameHit;
          }
        }
      }

      // 카테고리 보너스
      for(const key of (latin ? tokens : chars)){
        if(toLower(r.category).includes(key)) score += SCORE.categoryHit;
      }

      if(matched){ hits.push({r, score}); }
    }

    hits.sort((a,b)=> b.score - a.score);
    render(hits.slice(0, MAX_RESULTS).map(x=>x.r), q);
  }

  /** ====== 렌더 & 하이라이트 ====== */
  function highlight(text, query){
    if(!query) return esc(text);
    const q = toLower(query);
    const latin = isLatin(q);

    if(!latin){
      // 비라틴: 문자 집합 하이라이트
      const set = new Set(q.split(""));
      let out = "";
      for(const ch of text){
        if(set.has(toLower(ch))) out += "<mark>"+esc(ch)+"</mark>";
        else out += esc(ch);
      }
      return out;
    }else{
      // 라틴: 토큰 OR
      const tokens = uniq(q.split(/[\s,]+/).filter(Boolean)).sort((a,b)=>b.length-a.length);
      let html = esc(text);
      for(const t of tokens){
        if(!t) continue;
        const re = new RegExp("("+t.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")+")","ig");
        html = html.replace(re, "<mark>$1</mark>");
      }
      return html;
    }
  }

  function groupBy(items, keyFn){
    const m = new Map();
    for(const it of items){
      const k = keyFn(it) || "Uncategorized";
      if(!m.has(k)) m.set(k, []);
      m.get(k).push(it);
    }
    return m;
  }

  function render(items, query=""){
    if(!items.length){
      $list.innerHTML = "";
      $zero.style.display = "block";
      return;
    }
    $zero.style.display = "none";

    // 카테고리별 묶음
    const groups = groupBy(items, r=>r.category);
    let html = "";

    for(const [cat, arr] of groups){
      html += `<section class="sec">
        <div class="cat">${esc(cat)} <span class="cnt">${arr.length}</span></div>
        <div class="emojis">
          ${arr.map(r => {
            const title = esc(r.name || "");
            const nm = query ? `<div class="nm">${highlight(r.name || "", query)}</div>` : "";
            const kw = (query && r.safeKo) ? `<div class="kw">${highlight(r.safeKo, query)}</div>` : "";
            return `
              <div class="e" title="${title}">
                <span class="glyph">${esc(r.emoji || "⬜")}</span>
                ${ (nm || kw) ? `<div class="d">${nm}${kw}</div>` : "" }
              </div>
            `;
          }).join("")}
        </div>
      </section>`;
    }

    $list.innerHTML = html;
  }
  </script>
</body>
</html>
